---
title: 手撕常用代码
date: 2019-04-11 14:12:30
categories: 前端
tags: JavaScript
---
## 手撕常用代码

#### 夯实基础，日常练习，点滴积累，进阶提升。（长期维护更新）

####  1. 浅拷贝：

```
function clone(o) {
 	var _o = {};
 	for (let k in o) {
 		_o[k] = o[k];
 	}
 	return _o;
 }
```

####  2. 深拷贝：

```
function deepClone(o) {
 	if (typeof o === 'string' || typeof o === 'number' || typeof o === 'boolean' || typeof o === 'undefined') {
 		return o;
 	} else if (Array.isArray(o)) {
 		var arr = [];
 		for(let i = 0; i < o.length; i++) {
 			arr.push(deepClone(o[i]))
 		}
 		return arr;
 	} else if (typeof o === 'object') {
 		var obj = {};
 		for(let k in o) {
 			obj[k] = deepClone(o[k]);
 		}
 		return obj;
 	}
 }
```

<!--more-->

####  3. 柯里化函数

```
function curry(fn) {
 	return function() {
 		var args1 = arguments;
 		return function() {
 			var args2 = arguments;
 			return fn(...args1, ...args2);
 		}
 	}
 }

 eg：
 function add(num) {
 	let sunm = 0;
 	sum += num;
 	return function tempFun(numB) {
 		if (arguments.length === 0) {
 			return sum;
 		} else {
 			sum += numB;
 			return tempFun;
 		}
 	}
 }
```

####  4. 手动封装定时函数

```
function sleep(time) {
 	return new Promise((resolve) => setTimeout(resolve, time));
 }
```

####  5. reduce实现filter、map、数组扁平化等

```
Array.prototype._map = function(callback) {
 	if (typeof callback === 'function') {
 		return this.reduce((prev, item, index, arr) => {
 			prev.push(callback(item, index, arr));
 			return prev;
 		}, [])
 	} else {
 		console.log(new Error('callback is not function'));
 	}
 }
```

```
Array.prototype._filter = function(callback) {
 	if (typeof callback === 'function') {
 		return this.reduce((prev, item, index, arr) => {
 			callback(item, index, arr) ? prev.push(item) : null;
 			return prev;
 		}, [])
 	} else {
 		console.log(new Error('callback is not function'));
 	}
 }
```

```
// 求最大值/最小值
 let arr = [1, 2, 3, 4, 5];
 arr.reduce((prev, cur) => Math.max(prev, cur)); // 5
 arr.reduce((prev, cur) => Math.min(prev, cur)); // 1
```

```
// 数组去重
 let arr = [1, 2, 3, 1, 1, 2, 3, 3, 4, 3, 4, 5];
 let result = arr.reduce((prev, item, index, arr) => {
 	!prev.includes(item) && prev.push(item);
 	return prev;
 }, [])
console.log(result); // [1, 2, 3, 4, 5]
```

```
// 数组扁平化
 let arr = [1, 2, '3js', [4, 5, [6], [7, 8, [9, 10, 11], null, 'abc'], {age: 58}, [13, 14]], '[]', null];;
 function func(arr) {
 	if (Array.isArray(arr)) {
 		arr.reduce((prev, item, index, arr) => {
 			return Array.isArray(item) ? prev.concat(func(item)) : prev.concat(item);
 		})
 	} else {
 		throw new Error('arr is not array' );
 	}
 }
```

####  6. 防抖
```
 function debounce(fn, wait=500) {
 	let timer = null;
 	return function(...args) {
 		if (timer) {
 			clearTimeout(timer);
 		}

 		timer = setTimeout(() => {
 			fn.apply(this, args);
 		}, wait);
 	}
 }
```

#### 7. 节流
```
function throttle(fn, wait=500) {
 	let prev = new Date();
 	return function(...args) {
 		let now = new Date();
 		if (now - prev > wait) {
 			prev = now;
 			fn.apply(this, args);
 		}
 	}
 }
```

#### 8. 手撕 new

```
function _new() {
	let obj = {};	// 创建一个空对象
	let con = [].shift.call(arguments); // 获取构造函数
	obj.__proto__ = con.prototype; // 设置空对象的原型
	let res = con.apply(obj, arguments); // 绑定 this 并执行构造函数
	return res instanceof Object ? res : obj; // 确保返回值为对象
}
```

#### 9. 手撕call, apply, bind
call, apply, bind: 改变函数的执行上下文中的this指向，但不执行该函数(位于Function构造函数的原型对象上的方法)

- call接受多个参数，第一个为函数上下文也就是this，后边参数为函数本身的参数
- apply接受两个参数，第一个参数为函数上下文this，第二个参数为函数参数只不过是通过一个数组的形式传入的
- bind接收多个参数，第一个是bind返回值，返回值是一个函数上下文的this，不会立即执行


```
 Function.prototype.myCall = function(context = window) {
 	if (typeof this !== 'function') {
 		throw Error('myCall is not a function');
 	}
 	context.fn = this;	// 给context添加一个方法 指向this
 	// 处理参数，去除第一个参数this 其他传入fn
 	var args = [...arguments].slice(1);	// [...xxx]将类数组转为数组
 	var result = context.fn(...args); // 执行fn
 	delete context.fn; //删除方法
 	return result;
 }
```

```
 Function.prototype.myApply = function(context = window) {
 	if (typeof this !== 'function') {
 		throw Errror('myApply is not function');
 	}
 	context.fn = this;
 	var args = [...arguments].slice(1);
 	var result = context.fn(args);
 	delete context.fn;
 	return result;
 }
```

```
 Function.prototype.myBind = function(target) {
 	if (typeof this !== 'function') {
 		throw Error('myBind is not function');
 	}
 	var that = this; // 返回一个绑定this的函数，我们需要在此保存this
 	var args1 = [...arguments].slice(1); // 可以支持柯里化传参，保存参数
 	var func = function() {
 		var args2 = [...arguments]; // 同样因为支持柯里化形式传参，我们需要再次获取存储参数
 		return that.apply(traget || window, args1.concat(args2)); // 考虑返回函数有返回值做了return
 	}
 	return func;
 }
```

#### 10. 手动实现一个简单的async/await

```
// 定义一个Promise，用来模拟异步请求，作用是传入参数++
function getNum(num) {
	return new Promise((resolve, reject) => {

		setTimeout(() => {
			resolve(num + 1)
		}, 1000)
	})
}
```

```
// 所需要执行的Generator函数，内部的数据在执行完成一步的promise之后，再调用下一步
var func = function *() {
	const f1 = yield getNum(1);
	console.log(1);

	const f2 = yield getNum(2);
	console.log(2);
}
```

```
// 自动执行器，如果一个Generator函数没有执行完，则递归调用
function asyncFun(func) {
	var gen = func();

	function next(data) {
		var result = gen.next(data);

		if (result.done) return result.value;

		result.value.then(function(data) {
			next(data);
		})
	}

	next();
}
```

```
asyncFun(func);
```
